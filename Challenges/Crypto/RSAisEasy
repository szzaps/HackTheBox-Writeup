"""
Analyse
On a :
- n1 = p * q
- n2 = q * z
- On connaît n1, c1, c2
- On connaît (n1 * E) + n2 avec E inconnu (69 octets = 552 bits)
- e = 0x10001
- Le facteur q est commun à n1 et n2.
- On peut trouver q en calculant gcd(n1, n2), mais on n’a pas n2.
- Cependant, on a n1*E + n2 = K (connu).
- Puisque n2 = q*z et n1 = p*q, on a :
- K = n1*E + n2 = p*q*E + q*z = q*(p*E + z)
- Donc q divise K
- Mais q divise aussi n1. Donc q = gcd(n1, K).

Calcul de q

n1 = 101302608234750530215072272904674037076286246679691423280860345380727387460347553585319149306846617895151397345134725469568034944362725840889803514170441153452816738520513986621545456486260186057658467757935510362350710672577390455772286945685838373154626020209228183673388592030449624410459900543470481715269
c1 = 92506893588979548794790672542461288412902813248116064711808481112865246689691740816363092933206841082369015763989265012104504500670878633324061404374817814507356553697459987468562146726510492528932139036063681327547916073034377647100888763559498314765496171327071015998871821569774481702484239056959316014064
c2 = 46096854429474193473315622000700040188659289972305530955007054362815555622172000229584906225161285873027049199121215251038480738839915061587734141659589689176363962259066462128434796823277974789556411556028716349578708536050061871052948425521408788256153194537438422533790942307426802114531079426322801866673
K = 601613204734044874510382122719388369424704454445440856955212747733856646787417730534645761871794607755794569926160226856377491672497901427125762773794612714954548970049734347216746397532291215057264241745928752782099454036635249993278807842576939476615587990343335792606509594080976599605315657632227121700808996847129758656266941422227113386647519604149159248887809688029519252391934671647670787874483702292498358573950359909165677642135389614863992438265717898239252246163

import math
q = math.gcd(n1, K)
print("q =", q)

Factorisation
- Une fois q trouvé :
- p = n1 // q
- z = n2 // q mais on n’a pas n2.
- On peut obtenir n2 = K - n1*E, mais E inconnu
- Par contre, n2 = c2^d mod ? — pour déchiffrer c2, il faut phi(n2) = (q-1)*(z-1)
- Il nous faut z
- On peut trouver z via n2 = q*z
- Mais on n’a pas n2. On peut le retrouver si on trouve E
- De K = n1*E + n2 avec n2 < n1 (car q et z ~512 bits, n1 1024 bits, n2 aussi)
- Donc E = K // n1 (division entière) car n2 < n1

E = K // n1
n2 = K - n1 * E
print("E =", E)
print("n2 =", n2)

Puis z = n2 // q

Déchiffrement
- Avec p, q, z, on peut calculer :
- d1 = inverse(e, (p-1)*(q-1))
- d2 = inverse(e, (q-1)*(z-1))
- Déchiffrer c1 et c2 donne flag1 et flag2
"""

from Crypto.Util.number import long_to_bytes
import math

n1 = 101302608234750530215072272904674037076286246679691423280860345380727387460347553585319149306846617895151397345134725469568034944362725840889803514170441153452816738520513986621545456486260186057658467757935510362350710672577390455772286945685838373154626020209228183673388592030449624410459900543470481715269
c1 = 92506893588979548794790672542461288412902813248116064711808481112865246689691740816363092933206841082369015763989265012104504500670878633324061404374817814507356553697459987468562146726510492528932139036063681327547916073034377647100888763559498314765496171327071015998871821569774481702484239056959316014064
c2 = 46096854429474193473315622000700040188659289972305530955007054362815555622172000229584906225161285873027049199121215251038480738839915061587734141659589689176363962259066462128434796823277974789556411556028716349578708536050061871052948425521408788256153194537438422533790942307426802114531079426322801866673
K = 601613204734044874510382122719388369424704454445440856955212747733856646787417730534645761871794607755794569926160226856377491672497901427125762773794612714954548970049734347216746397532291215057264241745928752782099454036635249993278807842576939476615587990343335792606509594080976599605315657632227121700808996847129758656266941422227113386647519604149159248887809688029519252391934671647670787874483702292498358573950359909165677642135389614863992438265717898239252246163

e = 0x10001

q = math.gcd(n1, K)
p = n1 // q
E = K // n1
n2 = K - n1 * E
z = n2 // q

assert n1 == p * q
assert n2 == q * z
assert K == n1 * E + n2

def egcd(a, b):
    if b == 0:
        return a, 1, 0
    g, x1, y1 = egcd(b, a % b)
    return g, y1, x1 - (a // b) * y1

def modinv(a, m):
    g, x, _ = egcd(a, m)
    if g != 1:
        raise Exception('Modular inverse does not exist')
    return x % m

phi1 = (p - 1) * (q - 1)
phi2 = (q - 1) * (z - 1)

d1 = modinv(e, phi1)
d2 = modinv(e, phi2)

flag1 = pow(c1, d1, n1)
flag2 = pow(c2, d2, n2)

print(long_to_bytes(flag1))
print(long_to_bytes(flag2))
